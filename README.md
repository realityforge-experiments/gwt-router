# Router: Experiments with a raw gwt router

[![Build Status](https://secure.travis-ci.org/realityforge/gwt-router.png?branch=master)](http://travis-ci.org/realityforge/gwt-router)

## What is Router?

A project that experiments with simplified routing under gwt.
https://github.com/ReactTraining/react-router

## Router API

This library provides a low-level library for implementing routing or places management within
a web application. The library is designed to be used in conjunction with other higher-level
routing libraries to implement routing within an application.

The routing library attempts to perform routing in 3 distinct phases.

* `Change`: This phase occurs before routing actually occurs and may result in routing being
  aborted before being completed. This is where the code that implements guards and security checks
  is expected to be located. On completion the `Exit` chain is invoked for the existing location and
  then the `Enter` chain is invoked for the new location.
* `Enter`: This phase actually implements the routing operations. The updating of the UI typically
  occurs within this phase.
* `Exit`: This phase occurs is used to allow code to execute when a location is moved away from.

Each phase consists of a chain of callbacks that are invoked in succession. Each phase consists of
a unique callback interface that defines the operations allowed during that phase. Each callback has a
synchronous as well as an asynchronous variant. The asynchronous variant should be used sparingly
as it may lead to an unresponsive UI if the callback takes a long time to complete. The `Change`
callback chain is passed a control that allows aborting further route processing and this is typically
used when the callback redirects to a different location. The `Enter` phase is also passed a control
that can terminate further processing of the callback chain and this is typically done when processing
is complete.

The current application bases the location on the hash in the url. When the "location" in an application
changes, the application calls into the `RouteManager` to generate the list of callbacks for each phase
and then iterates through each callback. The list of callbacks for each phase is generated by the 
`RouteManager`. The `RouteManager` contains a list of `RouteDefinition` objects. Each `RouteDefinition`
object includes a pattern that is matched against the new location. The `RouteDefinition` also has
mechanisms for extracting key-value parameters from the matched location. The `RouteDefinition` also
includes one or more callbacks that can be added to the respective phases.

## TODO:

* If router parameters are mapped to fields then updating fields should update url.
* Route callbacks can be sync or async. Optional parameter indicating the variety.
* Routes may not terminate the search. i.e. A Route may "match" but all it does is add hooks and let matching continue.
* Start to document router.
* Write annotation processor that generates and configures 1 or more router managers based on the presence of annotations.
* Support routes that dynamically load routes. i.e. Add a route that dynamically loads a set of routes and replaces itself with them.
* Support either child or peer routers. These routers pick up optional routes that are suffixed to the main route and delegated to separate components. Typically these will be things like popup dialogs that contain some state. 
